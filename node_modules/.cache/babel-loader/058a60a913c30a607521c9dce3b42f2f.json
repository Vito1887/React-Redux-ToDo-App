{"ast":null,"code":"// src/utils/react.ts\nimport * as React from \"react\"; // src/utils/react-is.ts\n\nvar IS_REACT_19 = /* @__PURE__ */React.version.startsWith(\"19\");\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */Symbol.for(IS_REACT_19 ? \"react.transitional.element\" : \"react.element\");\nvar REACT_PORTAL_TYPE = /* @__PURE__ */Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = /* @__PURE__ */Symbol.for(\"react.profiler\");\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */Symbol.for(\"react.consumer\");\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */Symbol.for(\"react.context\");\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = /* @__PURE__ */Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = /* @__PURE__ */Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\n\nfunction isValidElementType(type) {\n  return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === \"object\" && object !== null) {\n    const {\n      $$typeof\n    } = object;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        switch (object = object.type, object) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return object;\n\n          default:\n            switch (object = object && object.$$typeof, object) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n                return object;\n\n              case REACT_CONSUMER_TYPE:\n                return object;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n}\n\nfunction isContextConsumer(object) {\n  return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\n}\n\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n} // src/utils/warning.ts\n\n\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (e) {}\n} // src/connect/verifySubselectors.ts\n\n\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n    }\n  }\n}\n\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n} // src/connect/selectorFactory.ts\n\n\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {\n  let {\n    areStatesEqual,\n    areOwnPropsEqual,\n    areStatePropsEqual\n  } = _ref;\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\n\nfunction finalPropsSelectorFactory(dispatch, _ref2) {\n  let {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps,\n    ...options\n  } = _ref2;\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n} // src/utils/bindActionCreators.ts\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = function () {\n        return dispatch(actionCreator(...arguments));\n      };\n    }\n  }\n\n  return boundActionCreators;\n} // src/utils/isPlainObject.ts\n\n\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) return false;\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  let baseProto = proto;\n\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n\n  return proto === baseProto;\n} // src/utils/verifyPlainObject.ts\n\n\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n  }\n} // src/connect/wrapMapToProps.ts\n\n\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\n\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref3) {\n    let {\n      displayName\n    } = _ref3;\n\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (process.env.NODE_ENV !== \"production\") verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n\n    return proxy;\n  };\n} // src/connect/invalidArgFactory.ts\n\n\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n  };\n} // src/connect/mapDispatchToProps.ts\n\n\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(dispatch => // @ts-ignore\n  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({\n    dispatch\n  })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n} // src/connect/mapStateToProps.ts\n\n\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n} // src/connect/mergeProps.ts\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return { ...ownProps,\n    ...stateProps,\n    ...dispatchProps\n  };\n}\n\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref4) {\n    let {\n      displayName,\n      areMergedPropsEqual\n    } = _ref4;\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (process.env.NODE_ENV !== \"production\") verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n\n      return mergedProps;\n    };\n  };\n}\n\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n} // src/utils/batch.ts\n\n\nfunction defaultNoopBatch(callback) {\n  callback();\n} // src/utils/Subscription.ts\n\n\nfunction createListenerCollection() {\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n\n    notify() {\n      defaultNoopBatch(() => {\n        let listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n\n    get() {\n      const listeners = [];\n      let listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n\n    subscribe(callback) {\n      let isSubscribed = true;\n      const listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n\n  };\n}\n\nvar nullListeners = {\n  notify() {},\n\n  get: () => []\n};\n\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  let subscriptionsAmount = 0;\n  let selfSubscribed = false;\n\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener);\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++;\n\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n} // src/utils/useIsomorphicLayoutEffect.ts\n\n\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n\nvar isDOM = /* @__PURE__ */canUseDOM();\n\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\n\nvar isReactNative = /* @__PURE__ */isRunningInReactNative();\n\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React.useLayoutEffect : React.useEffect;\n\nvar useIsomorphicLayoutEffect = /* @__PURE__ */getUseIsomorphicLayoutEffect(); // src/utils/shallowEqual.ts\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n} // src/utils/hoistStatics.ts\n\n\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS\n};\n\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n\n    let keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    const targetStatics = getStatics(targetComponent);\n    const sourceStatics = getStatics(sourceComponent);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n} // src/components/Context.ts\n\n\nvar ContextKey = /* @__PURE__ */Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis :\n/* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\n\nfunction getContext() {\n  if (!React.createContext) return {};\n  const contextMap = gT[ContextKey] ??= /* @__PURE__ */new Map();\n  let realContext = contextMap.get(React.createContext);\n\n  if (!realContext) {\n    realContext = React.createContext(null);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      realContext.displayName = \"ReactRedux\";\n    }\n\n    contextMap.set(React.createContext, realContext);\n  }\n\n  return realContext;\n}\n\nvar ReactReduxContext = /* @__PURE__ */getContext(); // src/components/connect.tsx\n\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\n\nvar stringifyComponent = Comp => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\n\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n}\n\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\n\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return () => {};\n  let didUnsubscribe = false;\n  let lastThrownError = null;\n\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n\n    try {\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n\n    if (!error) {\n      lastThrownError = null;\n    }\n\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n\n  return unsubscribeWrapper;\n}\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n\nvar hasWarnedAboutDeprecatedPureOption = false;\n\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n  let {\n    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure,\n    areStatesEqual = strictEqual,\n    areOwnPropsEqual = shallowEqual,\n    areStatePropsEqual = shallowEqual,\n    areMergedPropsEqual = shallowEqual,\n    // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false,\n    // the context consumer to use\n    context = ReactReduxContext\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n    }\n  }\n\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n\n  const wrapWithConnect = WrappedComponent => {\n    if (process.env.NODE_ENV !== \"production\") {\n      const isValid = /* @__PURE__ */isValidElementType(WrappedComponent);\n      if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n    }\n\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {\n        const {\n          reactReduxForwardedRef: reactReduxForwardedRef2,\n          ...wrapperProps2\n        } = props;\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\n      }, [props]);\n      const ContextToUse = React.useMemo(() => {\n        let ResultContext = Context;\n\n        if (propsContext?.Consumer) {\n          if (process.env.NODE_ENV !== \"production\") {\n            const isValid = /* @__PURE__ */isContextConsumer( // @ts-ignore\n\n            /* @__PURE__ */\n            React.createElement(propsContext.Consumer, null));\n\n            if (!isValid) {\n              throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n            }\n\n            ResultContext = propsContext;\n          }\n        }\n\n        return ResultContext;\n      }, [propsContext, Context]);\n      const contextValue = React.useContext(ContextToUse);\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n\n      if (process.env.NODE_ENV !== \"production\" && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n      }\n\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = React.useMemo(() => {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n        const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n        return [subscription2, notifyNestedSubs2];\n      }, [store, didStoreComeFromProps, contextValue]);\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n\n        return { ...contextValue,\n          subscription\n        };\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      const lastChildProps = React.useRef(void 0);\n      const lastWrapperProps = React.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = React.useRef(void 0);\n      const renderIsScheduled = React.useRef(false);\n      const isMounted = React.useRef(false);\n      const latestSubscriptionCallbackError = React.useRef(void 0);\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n\n        return selector;\n      }, [store, wrapperProps]);\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = reactListener => {\n          if (!subscription) {\n            return () => {};\n          }\n\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      let actualChildProps;\n\n      try {\n        actualChildProps = React.useSyncExternalStore( // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n        }\n\n        throw err;\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (// @ts-ignore\n\n          /* @__PURE__ */\n          React.createElement(WrappedComponent, { ...actualChildProps,\n            ref: reactReduxForwardedRef\n          })\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n\n    const _Connect = React.memo(ConnectFunction);\n\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        return /* @__PURE__ */React.createElement(Connect, { ...props,\n          reactReduxForwardedRef: ref\n        });\n      });\n\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n\n    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);\n  };\n\n  return wrapWithConnect;\n}\n\nvar connect_default = connect; // src/components/Provider.tsx\n\nfunction Provider(providerProps) {\n  const {\n    children,\n    context,\n    serverState,\n    store\n  } = providerProps;\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store);\n    const baseContextValue = {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : void 0\n    };\n\n    if (process.env.NODE_ENV === \"production\") {\n      return baseContextValue;\n    } else {\n      const {\n        identityFunctionCheck = \"once\",\n        stabilityCheck = \"once\"\n      } = providerProps;\n      return /* @__PURE__ */Object.assign(baseContextValue, {\n        stabilityCheck,\n        identityFunctionCheck\n      });\n    }\n  }, [store, serverState]);\n  const previousState = React.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const {\n      subscription\n    } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext;\n  return /* @__PURE__ */React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nvar Provider_default = Provider; // src/hooks/useReduxContext.ts\n\nfunction createReduxContextHook() {\n  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  return function useReduxContext2() {\n    const contextValue = React.useContext(context);\n\n    if (process.env.NODE_ENV !== \"production\" && !contextValue) {\n      throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n    }\n\n    return contextValue;\n  };\n}\n\nvar useReduxContext = /* @__PURE__ */createReduxContextHook(); // src/hooks/useStore.ts\n\nfunction createStoreHook() {\n  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n  createReduxContextHook(context);\n\n  const useStore2 = () => {\n    const {\n      store\n    } = useReduxContext2();\n    return store;\n  };\n\n  Object.assign(useStore2, {\n    withTypes: () => useStore2\n  });\n  return useStore2;\n}\n\nvar useStore = /* @__PURE__ */createStoreHook(); // src/hooks/useDispatch.ts\n\nfunction createDispatchHook() {\n  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n\n  const useDispatch2 = () => {\n    const store = useStore2();\n    return store.dispatch;\n  };\n\n  Object.assign(useDispatch2, {\n    withTypes: () => useDispatch2\n  });\n  return useDispatch2;\n}\n\nvar useDispatch = /* @__PURE__ */createDispatchHook(); // src/hooks/useSelector.ts\n\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/with-selector.js\";\n\nvar refEquality = (a, b) => a === b;\n\nfunction createSelectorHook() {\n  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n\n  const useSelector2 = function (selector) {\n    let equalityFnOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      equalityFn = refEquality\n    } = typeof equalityFnOrOptions === \"function\" ? {\n      equalityFn: equalityFnOrOptions\n    } : equalityFnOrOptions;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n\n      if (typeof selector !== \"function\") {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(`You must pass a function as an equality function to useSelector`);\n      }\n    }\n\n    const reduxContext = useReduxContext2();\n    const {\n      store,\n      subscription,\n      getServerState\n    } = reduxContext;\n    const firstRun = React.useRef(true);\n    const wrappedSelector = React.useCallback({\n      [selector.name](state) {\n        const selected = selector(state);\n\n        if (process.env.NODE_ENV !== \"production\") {\n          const {\n            devModeChecks = {}\n          } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\n          const {\n            identityFunctionCheck,\n            stabilityCheck\n          } = reduxContext;\n          const {\n            identityFunctionCheck: finalIdentityFunctionCheck,\n            stabilityCheck: finalStabilityCheck\n          } = {\n            stabilityCheck,\n            identityFunctionCheck,\n            ...devModeChecks\n          };\n\n          if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n            const toCompare = selector(state);\n\n            if (!equalityFn(selected, toCompare)) {\n              let stack = void 0;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n\n              console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                state,\n                selected,\n                selected2: toCompare,\n                stack\n              });\n            }\n          }\n\n          if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n            if (selected === state) {\n              let stack = void 0;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n\n              console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                stack\n              });\n            }\n          }\n\n          if (firstRun.current) firstRun.current = false;\n        }\n\n        return selected;\n      }\n\n    }[selector.name], [selector]);\n    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    React.useDebugValue(selectedState);\n    return selectedState;\n  };\n\n  Object.assign(useSelector2, {\n    withTypes: () => useSelector2\n  });\n  return useSelector2;\n}\n\nvar useSelector = /* @__PURE__ */createSelectorHook(); // src/exports.ts\n\nvar batch = defaultNoopBatch;\nexport { Provider_default as Provider, ReactReduxContext, batch, connect_default as connect, createDispatchHook, createSelectorHook, createStoreHook, shallowEqual, useDispatch, useSelector, useStore };","map":{"version":3,"mappings":"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","names":["React","IS_REACT_19","version","startsWith","REACT_ELEMENT_TYPE","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_OFFSCREEN_TYPE","REACT_CLIENT_REFERENCE","ForwardRef","Memo","isValidElementType","type","$$typeof","getModuleId","typeOf","object","isContextConsumer","isMemo","warning","message","console","error","Error","e","verify","selector","methodName","Object","prototype","hasOwnProperty","call","verifySubselectors","mapStateToProps","mapDispatchToProps","mergeProps","pureFinalPropsSelectorFactory","dispatch","areStatesEqual","areOwnPropsEqual","areStatePropsEqual","hasRunAtLeastOnce","state","ownProps","stateProps","dispatchProps","mergedProps","handleFirstCall","firstState","firstOwnProps","handleNewPropsAndNewState","dependsOnOwnProps","handleNewProps","handleNewState","nextStateProps","statePropsChanged","handleSubsequentCalls","nextState","nextOwnProps","propsChanged","stateChanged","pureFinalPropsSelector","finalPropsSelectorFactory","initMapStateToProps","initMapDispatchToProps","initMergeProps","options","process","env","NODE_ENV","bindActionCreators","actionCreators","boundActionCreators","key","actionCreator","isPlainObject","obj","proto","getPrototypeOf","baseProto","verifyPlainObject","value","displayName","wrapMapToPropsConstant","getConstant","initConstantSelector","constant","constantSelector","getDependsOnOwnProps","mapToProps","Boolean","length","wrapMapToPropsFunc","initProxySelector","proxy","mapToPropsProxy","stateOrDispatch","detectFactoryAndVerify","props","createInvalidArgFactory","arg","name","wrappedComponentName","mapDispatchToPropsFactory","mapStateToPropsFactory","defaultMergeProps","wrapMergePropsFunc","initMergePropsProxy","areMergedPropsEqual","hasRunOnce","mergePropsProxy","nextMergedProps","mergePropsFactory","defaultNoopBatch","callback","createListenerCollection","first","last","clear","notify","listener","next","get","listeners","push","subscribe","isSubscribed","prev","unsubscribe","nullListeners","createSubscription","store","parentSub","subscriptionsAmount","selfSubscribed","addNestedSub","trySubscribe","cleanupListener","removed","tryUnsubscribe","notifyNestedSubs","handleChangeWrapper","subscription","onStateChange","trySubscribeSelf","tryUnsubscribeSelf","getListeners","canUseDOM","window","document","createElement","isDOM","isRunningInReactNative","navigator","product","isReactNative","getUseIsomorphicLayoutEffect","useLayoutEffect","useEffect","useIsomorphicLayoutEffect","is","x","y","shallowEqual","objA","objB","keysA","keys","keysB","i","REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","KNOWN_STATICS","caller","callee","arguments","arity","FORWARD_REF_STATICS","render","MEMO_STATICS","compare","TYPE_STATICS","getStatics","component","defineProperty","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","inheritedComponent","concat","targetStatics","sourceStatics","descriptor","ContextKey","gT","globalThis","getContext","createContext","contextMap","Map","realContext","set","ReactReduxContext","NO_SUBSCRIPTION_ARRAY","stringifyComponent","Comp","JSON","stringify","err","String","useIsomorphicLayoutEffectWithArgs","effectFunc","effectArgs","dependencies","captureWrapperProps","lastWrapperProps","lastChildProps","renderIsScheduled","wrapperProps","childPropsFromStoreUpdate","current","subscribeUpdates","shouldHandleStateChanges","childPropsSelector","isMounted","additionalSubscribeListener","didUnsubscribe","lastThrownError","checkForUpdates","latestStoreState","getState","newChildProps","unsubscribeWrapper","strictEqual","a","b","hasWarnedAboutDeprecatedPureOption","connect","pure","forwardRef","context","Context","wrapWithConnect","WrappedComponent","isValid","selectorFactoryOptions","ConnectFunction","propsContext","reactReduxForwardedRef","useMemo","ContextToUse","ResultContext","Consumer","contextValue","useContext","didStoreComeFromProps","didStoreComeFromContext","getServerState","bind","overriddenContextValue","useRef","latestSubscriptionCallbackError","actualChildPropsSelector","subscribeForReact","reactListener","actualChildProps","useSyncExternalStore","stack","renderedWrappedComponent","ref","renderedChild","Provider","_Connect","memo","Connect","_forwarded","forwardConnectRef","forwarded","connect_default","providerProps","children","serverState","baseContextValue","identityFunctionCheck","stabilityCheck","assign","previousState","Provider_default","createReduxContextHook","useReduxContext","createStoreHook","useStore","withTypes","createDispatchHook","useDispatch","useSyncExternalStoreWithSelector","refEquality","createSelectorHook","useSelector","equalityFnOrOptions","equalityFn","reduxContext","firstRun","wrappedSelector","useCallback","selected","devModeChecks","finalIdentityFunctionCheck","finalStabilityCheck","toCompare","warn","selected2","selectedState","useDebugValue","batch"],"sources":["/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/react.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/react-is.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/warning.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/verifySubselectors.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/selectorFactory.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/bindActionCreators.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/isPlainObject.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/verifyPlainObject.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/wrapMapToProps.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/invalidArgFactory.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/mapDispatchToProps.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/mapStateToProps.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/connect/mergeProps.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/batch.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/Subscription.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/useIsomorphicLayoutEffect.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/shallowEqual.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/utils/hoistStatics.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/components/Context.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/components/connect.tsx","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/components/Provider.tsx","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/hooks/useReduxContext.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/hooks/useStore.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/hooks/useDispatch.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/hooks/useSelector.ts","/Users/user/WebstormProjects/github/React-Redux-ToDo-App/node_modules/react-redux/src/exports.ts"],"sourcesContent":["import * as React from 'react'\n\nexport { React }\n","import type { ElementType, MemoExoticComponent, ReactElement } from 'react'\nimport { React } from './react'\n\n// Directly ported from:\n// https://unpkg.com/browse/react-is@19.0.0/cjs/react-is.production.js\n// It's very possible this could change in the future, but given that\n// we only use these in `connect`, this is a low priority.\n\nexport const IS_REACT_19 = /* @__PURE__ */ React.version.startsWith('19')\n\nconst REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(\n  IS_REACT_19 ? 'react.transitional.element' : 'react.element',\n)\nconst REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for('react.portal')\nconst REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for('react.fragment')\nconst REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for('react.strict_mode')\nconst REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for('react.profiler')\nconst REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for('react.consumer')\nconst REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for('react.context')\nconst REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for('react.forward_ref')\nconst REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for('react.suspense')\nconst REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\n  'react.suspense_list',\n)\nconst REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for('react.memo')\nconst REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for('react.lazy')\nconst REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for('react.offscreen')\nconst REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\n  'react.client.reference',\n)\n\nexport const ForwardRef = REACT_FORWARD_REF_TYPE\nexport const Memo = REACT_MEMO_TYPE\n\nexport function isValidElementType(type: any): type is ElementType {\n  return typeof type === 'string' ||\n    typeof type === 'function' ||\n    type === REACT_FRAGMENT_TYPE ||\n    type === REACT_PROFILER_TYPE ||\n    type === REACT_STRICT_MODE_TYPE ||\n    type === REACT_SUSPENSE_TYPE ||\n    type === REACT_SUSPENSE_LIST_TYPE ||\n    type === REACT_OFFSCREEN_TYPE ||\n    (typeof type === 'object' &&\n      type !== null &&\n      (type.$$typeof === REACT_LAZY_TYPE ||\n        type.$$typeof === REACT_MEMO_TYPE ||\n        type.$$typeof === REACT_CONTEXT_TYPE ||\n        type.$$typeof === REACT_CONSUMER_TYPE ||\n        type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        type.$$typeof === REACT_CLIENT_REFERENCE ||\n        type.getModuleId !== undefined))\n    ? !0\n    : !1\n}\n\nfunction typeOf(object: any): symbol | undefined {\n  if (typeof object === 'object' && object !== null) {\n    const { $$typeof } = object\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        switch (((object = object.type), object)) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return object\n          default:\n            switch (((object = object && object.$$typeof), object)) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n                return object\n              case REACT_CONSUMER_TYPE:\n                return object\n              default:\n                return $$typeof\n            }\n        }\n      case REACT_PORTAL_TYPE:\n        return $$typeof\n    }\n  }\n}\n\nexport function isContextConsumer(object: any): object is ReactElement {\n  return IS_REACT_19\n    ? typeOf(object) === REACT_CONSUMER_TYPE\n    : typeOf(object) === REACT_CONTEXT_TYPE\n}\n\nexport function isMemo(object: any): object is MemoExoticComponent<any> {\n  return typeOf(object) === REACT_MEMO_TYPE\n}\n","/**\r\n * Prints a warning in the console if it exists.\r\n *\r\n * @param {String} message The warning message.\r\n * @returns {void}\r\n */\r\nexport default function warning(message: string) {\r\n  /* eslint-disable no-console */\r\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\r\n    console.error(message)\r\n  }\r\n  /* eslint-enable no-console */\r\n  try {\r\n    // This error was thrown as a convenience so that if you enable\r\n    // \"break on all exceptions\" in your console,\r\n    // it would pause the execution at this line.\r\n    throw new Error(message)\r\n    /* eslint-disable no-empty */\r\n  } catch (e) {}\r\n  /* eslint-enable no-empty */\r\n}\r\n","import warning from '../utils/warning'\n\nfunction verify(selector: unknown, methodName: string): void {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`)\n  } else if (\n    methodName === 'mapStateToProps' ||\n    methodName === 'mapDispatchToProps'\n  ) {\n    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {\n      warning(\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`,\n      )\n    }\n  }\n}\n\nexport default function verifySubselectors(\n  mapStateToProps: unknown,\n  mapDispatchToProps: unknown,\n  mergeProps: unknown,\n): void {\n  verify(mapStateToProps, 'mapStateToProps')\n  verify(mapDispatchToProps, 'mapDispatchToProps')\n  verify(mergeProps, 'mergeProps')\n}\n","import type { Dispatch, Action } from 'redux'\nimport type { ComponentType } from 'react'\nimport verifySubselectors from './verifySubselectors'\nimport type { EqualityFn, ExtendedEqualityFn } from '../types'\n\nexport type SelectorFactory<S, TProps, TOwnProps, TFactoryOptions> = (\n  dispatch: Dispatch<Action<string>>,\n  factoryOptions: TFactoryOptions,\n) => Selector<S, TProps, TOwnProps>\n\nexport type Selector<S, TProps, TOwnProps = null> = TOwnProps extends\n  | null\n  | undefined\n  ? (state: S) => TProps\n  : (state: S, ownProps: TOwnProps) => TProps\n\nexport type MapStateToProps<TStateProps, TOwnProps, State> = (\n  state: State,\n  ownProps: TOwnProps,\n) => TStateProps\n\nexport type MapStateToPropsFactory<TStateProps, TOwnProps, State> = (\n  initialState: State,\n  ownProps: TOwnProps,\n) => MapStateToProps<TStateProps, TOwnProps, State>\n\nexport type MapStateToPropsParam<TStateProps, TOwnProps, State> =\n  | MapStateToPropsFactory<TStateProps, TOwnProps, State>\n  | MapStateToProps<TStateProps, TOwnProps, State>\n  | null\n  | undefined\n\nexport type MapDispatchToPropsFunction<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action<string>>,\n  ownProps: TOwnProps,\n) => TDispatchProps\n\nexport type MapDispatchToProps<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n  | TDispatchProps\n\nexport type MapDispatchToPropsFactory<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action<string>>,\n  ownProps: TOwnProps,\n) => MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n\nexport type MapDispatchToPropsParam<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\n  | MapDispatchToProps<TDispatchProps, TOwnProps>\n\nexport type MapDispatchToPropsNonObject<TDispatchProps, TOwnProps> =\n  | MapDispatchToPropsFactory<TDispatchProps, TOwnProps>\n  | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>\n\nexport type MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> = (\n  stateProps: TStateProps,\n  dispatchProps: TDispatchProps,\n  ownProps: TOwnProps,\n) => TMergedProps\n\ninterface PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\n  readonly areStatesEqual: ExtendedEqualityFn<State, TOwnProps>\n  readonly areStatePropsEqual: EqualityFn<TStateProps>\n  readonly areOwnPropsEqual: EqualityFn<TOwnProps>\n}\n\nfunction pureFinalPropsSelectorFactory<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State,\n>(\n  mapStateToProps: WrappedMapStateToProps<TStateProps, TOwnProps, State>,\n  mapDispatchToProps: WrappedMapDispatchToProps<TDispatchProps, TOwnProps>,\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n  dispatch: Dispatch<Action<string>>,\n  {\n    areStatesEqual,\n    areOwnPropsEqual,\n    areStatePropsEqual,\n  }: PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State>,\n) {\n  let hasRunAtLeastOnce = false\n  let state: State\n  let ownProps: TOwnProps\n  let stateProps: TStateProps\n  let dispatchProps: TDispatchProps\n  let mergedProps: TMergedProps\n\n  function handleFirstCall(firstState: State, firstOwnProps: TOwnProps) {\n    state = firstState\n    ownProps = firstOwnProps\n    stateProps = mapStateToProps(state, ownProps)\n    dispatchProps = mapDispatchToProps(dispatch, ownProps)\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce = true\n    return mergedProps\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps)\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)\n    stateProps = nextStateProps\n\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n    return mergedProps\n  }\n\n  function handleSubsequentCalls(nextState: State, nextOwnProps: TOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\n    const stateChanged = !areStatesEqual(\n      nextState,\n      state,\n      nextOwnProps,\n      ownProps,\n    )\n    state = nextState\n    ownProps = nextOwnProps\n\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  }\n\n  return function pureFinalPropsSelector(\n    nextState: State,\n    nextOwnProps: TOwnProps,\n  ) {\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  }\n}\n\ninterface WrappedMapStateToProps<TStateProps, TOwnProps, State> {\n  (state: State, ownProps: TOwnProps): TStateProps\n  readonly dependsOnOwnProps: boolean\n}\n\ninterface WrappedMapDispatchToProps<TDispatchProps, TOwnProps> {\n  (dispatch: Dispatch<Action<string>>, ownProps: TOwnProps): TDispatchProps\n  readonly dependsOnOwnProps: boolean\n}\n\nexport interface InitOptions<TStateProps, TOwnProps, TMergedProps, State>\n  extends PureSelectorFactoryComparisonOptions<TStateProps, TOwnProps, State> {\n  readonly shouldHandleStateChanges: boolean\n  readonly displayName: string\n  readonly wrappedComponentName: string\n  readonly WrappedComponent: ComponentType<TOwnProps>\n  readonly areMergedPropsEqual: EqualityFn<TMergedProps>\n}\n\nexport interface SelectorFactoryOptions<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State,\n> extends InitOptions<TStateProps, TOwnProps, TMergedProps, State> {\n  readonly initMapStateToProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>,\n  ) => WrappedMapStateToProps<TStateProps, TOwnProps, State>\n  readonly initMapDispatchToProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>,\n  ) => WrappedMapDispatchToProps<TDispatchProps, TOwnProps>\n  readonly initMergeProps: (\n    dispatch: Dispatch<Action<string>>,\n    options: InitOptions<TStateProps, TOwnProps, TMergedProps, State>,\n  ) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>\n}\n\n// TODO: Add more comments\n\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\n\nexport default function finalPropsSelectorFactory<\n  TStateProps,\n  TOwnProps,\n  TDispatchProps,\n  TMergedProps,\n  State,\n>(\n  dispatch: Dispatch<Action<string>>,\n  {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps,\n    ...options\n  }: SelectorFactoryOptions<\n    TStateProps,\n    TOwnProps,\n    TDispatchProps,\n    TMergedProps,\n    State\n  >,\n) {\n  const mapStateToProps = initMapStateToProps(dispatch, options)\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)\n  const mergeProps = initMergeProps(dispatch, options)\n\n  if (process.env.NODE_ENV !== 'production') {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps)\n  }\n\n  return pureFinalPropsSelectorFactory<\n    TStateProps,\n    TOwnProps,\n    TDispatchProps,\n    TMergedProps,\n    State\n  >(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options)\n}\n","import type { ActionCreatorsMapObject, Dispatch } from 'redux'\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreatorsMapObject,\n  dispatch: Dispatch,\n): ActionCreatorsMapObject {\n  const boundActionCreators: ActionCreatorsMapObject = {}\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args))\n    }\n  }\n  return boundActionCreators\n}\n","/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nexport default function isPlainObject(obj: unknown) {\n  if (typeof obj !== 'object' || obj === null) return false\n\n  const proto = Object.getPrototypeOf(obj)\n  if (proto === null) return true\n\n  let baseProto = proto\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto)\n  }\n\n  return proto === baseProto\n}\n","import isPlainObject from './isPlainObject'\nimport warning from './warning'\n\nexport default function verifyPlainObject(\n  value: unknown,\n  displayName: string,\n  methodName: string,\n) {\n  if (!isPlainObject(value)) {\n    warning(\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`,\n    )\n  }\n}\n","import type { ActionCreatorsMapObject, Dispatch, ActionCreator } from 'redux'\n\nimport type { FixTypeLater } from '../types'\nimport verifyPlainObject from '../utils/verifyPlainObject'\n\ntype AnyState = { [key: string]: any }\ntype StateOrDispatch<S extends AnyState = AnyState> = S | Dispatch\n\ntype AnyProps = { [key: string]: any }\n\nexport type MapToProps<P extends AnyProps = AnyProps> = {\n  // eslint-disable-next-line no-unused-vars\n  (stateOrDispatch: StateOrDispatch, ownProps?: P): FixTypeLater\n  dependsOnOwnProps?: boolean\n}\n\nexport function wrapMapToPropsConstant(\n  // * Note:\n  //  It seems that the dispatch argument\n  //  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n  //  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n  // eslint-disable-next-line no-unused-vars\n  getConstant: (dispatch: Dispatch) =>\n    | {\n        dispatch?: Dispatch\n        dependsOnOwnProps?: boolean\n      }\n    | ActionCreatorsMapObject\n    | ActionCreator<any>,\n) {\n  return function initConstantSelector(dispatch: Dispatch) {\n    const constant = getConstant(dispatch)\n\n    function constantSelector() {\n      return constant\n    }\n    constantSelector.dependsOnOwnProps = false\n    return constantSelector\n  }\n}\n\n// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\nfunction getDependsOnOwnProps(mapToProps: MapToProps) {\n  return mapToProps.dependsOnOwnProps\n    ? Boolean(mapToProps.dependsOnOwnProps)\n    : mapToProps.length !== 1\n}\n\n// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\nexport function wrapMapToPropsFunc<P extends AnyProps = AnyProps>(\n  mapToProps: MapToProps,\n  methodName: string,\n) {\n  return function initProxySelector(\n    dispatch: Dispatch,\n    { displayName }: { displayName: string },\n  ) {\n    const proxy = function mapToPropsProxy(\n      stateOrDispatch: StateOrDispatch,\n      ownProps?: P,\n    ): MapToProps {\n      return proxy.dependsOnOwnProps\n        ? proxy.mapToProps(stateOrDispatch, ownProps)\n        : proxy.mapToProps(stateOrDispatch, undefined)\n    }\n\n    // allow detectFactoryAndVerify to get ownProps\n    proxy.dependsOnOwnProps = true\n\n    proxy.mapToProps = function detectFactoryAndVerify(\n      stateOrDispatch: StateOrDispatch,\n      ownProps?: P,\n    ): MapToProps {\n      proxy.mapToProps = mapToProps\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)\n      let props = proxy(stateOrDispatch, ownProps)\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)\n        props = proxy(stateOrDispatch, ownProps)\n      }\n\n      if (process.env.NODE_ENV !== 'production')\n        verifyPlainObject(props, displayName, methodName)\n\n      return props\n    }\n\n    return proxy\n  }\n}\n","import type { Action, Dispatch } from 'redux'\n\nexport function createInvalidArgFactory(arg: unknown, name: string) {\n  return (\n    dispatch: Dispatch<Action<string>>,\n    options: { readonly wrappedComponentName: string },\n  ) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${\n        options.wrappedComponentName\n      }.`,\n    )\n  }\n}\n","import type { Action, Dispatch } from 'redux'\nimport bindActionCreators from '../utils/bindActionCreators'\nimport { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MapDispatchToPropsParam } from './selectorFactory'\n\nexport function mapDispatchToPropsFactory<TDispatchProps, TOwnProps>(\n  mapDispatchToProps:\n    | MapDispatchToPropsParam<TDispatchProps, TOwnProps>\n    | undefined,\n) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object'\n    ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) =>\n        // @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch),\n      )\n    : !mapDispatchToProps\n      ? wrapMapToPropsConstant((dispatch: Dispatch<Action<string>>) => ({\n          dispatch,\n        }))\n      : typeof mapDispatchToProps === 'function'\n        ? // @ts-ignore\n          wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')\n        : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps')\n}\n","import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MapStateToPropsParam } from './selectorFactory'\n\nexport function mapStateToPropsFactory<TStateProps, TOwnProps, State>(\n  mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n) {\n  return !mapStateToProps\n    ? wrapMapToPropsConstant(() => ({}))\n    : typeof mapStateToProps === 'function'\n      ? // @ts-ignore\n        wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')\n      : createInvalidArgFactory(mapStateToProps, 'mapStateToProps')\n}\n","import type { Action, Dispatch } from 'redux'\nimport verifyPlainObject from '../utils/verifyPlainObject'\nimport { createInvalidArgFactory } from './invalidArgFactory'\nimport type { MergeProps } from './selectorFactory'\nimport type { EqualityFn } from '../types'\n\nfunction defaultMergeProps<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps,\n>(\n  stateProps: TStateProps,\n  dispatchProps: TDispatchProps,\n  ownProps: TOwnProps,\n): TMergedProps {\n  // @ts-ignore\n  return { ...ownProps, ...stateProps, ...dispatchProps }\n}\n\nfunction wrapMergePropsFunc<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps,\n>(\n  mergeProps: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n): (\n  dispatch: Dispatch<Action<string>>,\n  options: {\n    readonly displayName: string\n    readonly areMergedPropsEqual: EqualityFn<TMergedProps>\n  },\n) => MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> {\n  return function initMergePropsProxy(\n    dispatch,\n    { displayName, areMergedPropsEqual },\n  ) {\n    let hasRunOnce = false\n    let mergedProps: TMergedProps\n\n    return function mergePropsProxy(\n      stateProps: TStateProps,\n      dispatchProps: TDispatchProps,\n      ownProps: TOwnProps,\n    ) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\n          mergedProps = nextMergedProps\n      } else {\n        hasRunOnce = true\n        mergedProps = nextMergedProps\n\n        if (process.env.NODE_ENV !== 'production')\n          verifyPlainObject(mergedProps, displayName, 'mergeProps')\n      }\n\n      return mergedProps\n    }\n  }\n}\n\nexport function mergePropsFactory<\n  TStateProps,\n  TDispatchProps,\n  TOwnProps,\n  TMergedProps,\n>(\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n) {\n  return !mergeProps\n    ? () => defaultMergeProps\n    : typeof mergeProps === 'function'\n      ? wrapMergePropsFunc(mergeProps)\n      : createInvalidArgFactory(mergeProps, 'mergeProps')\n}\n","// Default to a dummy \"batch\" implementation that just runs the callback\r\nexport function defaultNoopBatch(callback: () => void) {\r\n  callback()\r\n}\r\n","import { defaultNoopBatch as batch } from './batch'\n\n// encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\ntype VoidFunc = () => void\n\ntype Listener = {\n  callback: VoidFunc\n  next: Listener | null\n  prev: Listener | null\n}\n\nfunction createListenerCollection() {\n  let first: Listener | null = null\n  let last: Listener | null = null\n\n  return {\n    clear() {\n      first = null\n      last = null\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first\n        while (listener) {\n          listener.callback()\n          listener = listener.next\n        }\n      })\n    },\n\n    get() {\n      const listeners: Listener[] = []\n      let listener = first\n      while (listener) {\n        listeners.push(listener)\n        listener = listener.next\n      }\n      return listeners\n    },\n\n    subscribe(callback: () => void) {\n      let isSubscribed = true\n\n      const listener: Listener = (last = {\n        callback,\n        next: null,\n        prev: last,\n      })\n\n      if (listener.prev) {\n        listener.prev.next = listener\n      } else {\n        first = listener\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return\n        isSubscribed = false\n\n        if (listener.next) {\n          listener.next.prev = listener.prev\n        } else {\n          last = listener.prev\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next\n        } else {\n          first = listener.next\n        }\n      }\n    },\n  }\n}\n\ntype ListenerCollection = ReturnType<typeof createListenerCollection>\n\nexport interface Subscription {\n  addNestedSub: (listener: VoidFunc) => VoidFunc\n  notifyNestedSubs: VoidFunc\n  handleChangeWrapper: VoidFunc\n  isSubscribed: () => boolean\n  onStateChange?: VoidFunc | null\n  trySubscribe: VoidFunc\n  tryUnsubscribe: VoidFunc\n  getListeners: () => ListenerCollection\n}\n\nconst nullListeners = {\n  notify() {},\n  get: () => [],\n} as unknown as ListenerCollection\n\nexport function createSubscription(store: any, parentSub?: Subscription) {\n  let unsubscribe: VoidFunc | undefined\n  let listeners: ListenerCollection = nullListeners\n\n  // Reasons to keep the subscription active\n  let subscriptionsAmount = 0\n\n  // Is this specific subscription subscribed (or only nested ones?)\n  let selfSubscribed = false\n\n  function addNestedSub(listener: () => void) {\n    trySubscribe()\n\n    const cleanupListener = listeners.subscribe(listener)\n\n    // cleanup nested sub\n    let removed = false\n    return () => {\n      if (!removed) {\n        removed = true\n        cleanupListener()\n        tryUnsubscribe()\n      }\n    }\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify()\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange()\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++\n    if (!unsubscribe) {\n      unsubscribe = parentSub\n        ? parentSub.addNestedSub(handleChangeWrapper)\n        : store.subscribe(handleChangeWrapper)\n\n      listeners = createListenerCollection()\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe()\n      unsubscribe = undefined\n      listeners.clear()\n      listeners = nullListeners\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true\n      trySubscribe()\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false\n      tryUnsubscribe()\n    }\n  }\n\n  const subscription: Subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners,\n  }\n\n  return subscription\n}\n","import { React } from '../utils/react'\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\n// Matches logic in React's `shared/ExecutionEnvironment` file\nconst canUseDOM = () =>\n  !!(\n    typeof window !== 'undefined' &&\n    typeof window.document !== 'undefined' &&\n    typeof window.document.createElement !== 'undefined'\n  )\n\nconst isDOM = /* @__PURE__ */ canUseDOM()\n\n// Under React Native, we know that we always want to use useLayoutEffect\n\n/**\n * Checks if the code is running in a React Native environment.\n *\n * @returns Whether the code is running in a React Native environment.\n *\n * @see {@link https://github.com/facebook/react-native/issues/1331 Reference}\n */\nconst isRunningInReactNative = () =>\n  typeof navigator !== 'undefined' && navigator.product === 'ReactNative'\n\nconst isReactNative = /* @__PURE__ */ isRunningInReactNative()\n\nconst getUseIsomorphicLayoutEffect = () =>\n  isDOM || isReactNative ? React.useLayoutEffect : React.useEffect\n\nexport const useIsomorphicLayoutEffect =\n  /* @__PURE__ */ getUseIsomorphicLayoutEffect()\n","function is(x: unknown, y: unknown) {\r\n  if (x === y) {\r\n    return x !== 0 || y !== 0 || 1 / x === 1 / y\r\n  } else {\r\n    return x !== x && y !== y\r\n  }\r\n}\r\n\r\nexport default function shallowEqual(objA: any, objB: any) {\r\n  if (is(objA, objB)) return true\r\n\r\n  if (\r\n    typeof objA !== 'object' ||\r\n    objA === null ||\r\n    typeof objB !== 'object' ||\r\n    objB === null\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  const keysA = Object.keys(objA)\r\n  const keysB = Object.keys(objB)\r\n\r\n  if (keysA.length !== keysB.length) return false\r\n\r\n  for (let i = 0; i < keysA.length; i++) {\r\n    if (\r\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||\r\n      !is(objA[keysA[i]], objB[keysA[i]])\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n","// Copied directly from:\n// https://github.com/mridgway/hoist-non-react-statics/blob/main/src/index.js\n// https://unpkg.com/browse/@types/hoist-non-react-statics@3.3.6/index.d.ts\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nimport type { ForwardRefExoticComponent, MemoExoticComponent } from 'react'\nimport { ForwardRef, Memo, isMemo } from '../utils/react-is'\n\nconst REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true,\n} as const\n\nconst KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true,\n} as const\n\nconst FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n} as const\n\nconst MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true,\n} as const\n\nconst TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS,\n} as const\n\nfunction getStatics(component: any) {\n  // React v16.11 and below\n  if (isMemo(component)) {\n    return MEMO_STATICS\n  }\n\n  // React v16.12 and above\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS\n}\n\nexport type NonReactStatics<\n  Source,\n  C extends {\n    [key: string]: true\n  } = {},\n> = {\n  [key in Exclude<\n    keyof Source,\n    Source extends MemoExoticComponent<any>\n      ? keyof typeof MEMO_STATICS | keyof C\n      : Source extends ForwardRefExoticComponent<any>\n        ? keyof typeof FORWARD_REF_STATICS | keyof C\n        : keyof typeof REACT_STATICS | keyof typeof KNOWN_STATICS | keyof C\n  >]: Source[key]\n}\n\nconst defineProperty = Object.defineProperty\nconst getOwnPropertyNames = Object.getOwnPropertyNames\nconst getOwnPropertySymbols = Object.getOwnPropertySymbols\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor\nconst getPrototypeOf = Object.getPrototypeOf\nconst objectPrototype = Object.prototype\n\nexport default function hoistNonReactStatics<\n  Target,\n  Source,\n  CustomStatic extends {\n    [key: string]: true\n  } = {},\n>(\n  targetComponent: Target,\n  sourceComponent: Source,\n): Target & NonReactStatics<Source, CustomStatic> {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent)\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent)\n      }\n    }\n\n    let keys: (string | symbol)[] = getOwnPropertyNames(sourceComponent)\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent))\n    }\n\n    const targetStatics = getStatics(targetComponent)\n    const sourceStatics = getStatics(sourceComponent)\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i]\n      if (\n        !KNOWN_STATICS[key as keyof typeof KNOWN_STATICS] &&\n        !(sourceStatics && sourceStatics[key as keyof typeof sourceStatics]) &&\n        !(targetStatics && targetStatics[key as keyof typeof targetStatics])\n      ) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key)\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor!)\n        } catch (e) {\n          // ignore\n        }\n      }\n    }\n  }\n\n  return targetComponent as any\n}\n","import type { Context } from 'react'\nimport { React } from '../utils/react'\nimport type { Action, Store, UnknownAction } from 'redux'\nimport type { Subscription } from '../utils/Subscription'\nimport type { ProviderProps } from './Provider'\n\nexport interface ReactReduxContextValue<\n  SS = any,\n  A extends Action<string> = UnknownAction,\n> extends Pick<ProviderProps, 'stabilityCheck' | 'identityFunctionCheck'> {\n  store: Store<SS, A>\n  subscription: Subscription\n  getServerState?: () => SS\n}\n\nconst ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`)\nconst gT: {\n  [ContextKey]?: Map<\n    typeof React.createContext,\n    Context<ReactReduxContextValue | null>\n  >\n} = (\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {}\n) as any\n\nfunction getContext(): Context<ReactReduxContextValue | null> {\n  if (!React.createContext) return {} as any\n\n  const contextMap = (gT[ContextKey] ??= new Map<\n    typeof React.createContext,\n    Context<ReactReduxContextValue | null>\n  >())\n  let realContext = contextMap.get(React.createContext)\n  if (!realContext) {\n    realContext = React.createContext<ReactReduxContextValue | null>(\n      null as any,\n    )\n    if (process.env.NODE_ENV !== 'production') {\n      realContext.displayName = 'ReactRedux'\n    }\n    contextMap.set(React.createContext, realContext)\n  }\n  return realContext\n}\n\nexport const ReactReduxContext = /*#__PURE__*/ getContext()\n\nexport type ReactReduxContextInstance = typeof ReactReduxContext\n","/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\nimport type { ComponentType } from 'react'\nimport { React } from '../utils/react'\nimport { isValidElementType, isContextConsumer } from '../utils/react-is'\n\nimport type { Store } from 'redux'\n\nimport type {\n  ConnectedComponent,\n  InferableComponentEnhancer,\n  InferableComponentEnhancerWithProps,\n  ResolveThunks,\n  DispatchProp,\n  ConnectPropsMaybeWithoutContext,\n} from '../types'\n\nimport type {\n  MapStateToPropsParam,\n  MapDispatchToPropsParam,\n  MergeProps,\n  MapDispatchToPropsNonObject,\n  SelectorFactoryOptions,\n} from '../connect/selectorFactory'\nimport defaultSelectorFactory from '../connect/selectorFactory'\nimport { mapDispatchToPropsFactory } from '../connect/mapDispatchToProps'\nimport { mapStateToPropsFactory } from '../connect/mapStateToProps'\nimport { mergePropsFactory } from '../connect/mergeProps'\n\nimport type { Subscription } from '../utils/Subscription'\nimport { createSubscription } from '../utils/Subscription'\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\nimport shallowEqual from '../utils/shallowEqual'\nimport hoistStatics from '../utils/hoistStatics'\nimport warning from '../utils/warning'\n\nimport type {\n  ReactReduxContextValue,\n  ReactReduxContextInstance,\n} from './Context'\nimport { ReactReduxContext } from './Context'\n\n// Define some constant arrays just to avoid re-creating these\nconst EMPTY_ARRAY: [unknown, number] = [null, 0]\nconst NO_SUBSCRIPTION_ARRAY = [null, null]\n\n// Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\nconst stringifyComponent = (Comp: unknown) => {\n  try {\n    return JSON.stringify(Comp)\n  } catch (err) {\n    return String(Comp)\n  }\n}\n\ntype EffectFunc = (...args: any[]) => void | ReturnType<React.EffectCallback>\n\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(\n  effectFunc: EffectFunc,\n  effectArgs: any[],\n  dependencies?: React.DependencyList,\n) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies)\n}\n\n// Effect callback, extracted: assign the latest props values to refs for later usage\nfunction captureWrapperProps(\n  lastWrapperProps: React.MutableRefObject<unknown>,\n  lastChildProps: React.MutableRefObject<unknown>,\n  renderIsScheduled: React.MutableRefObject<boolean>,\n  wrapperProps: unknown,\n  // actualChildProps: unknown,\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\n  notifyNestedSubs: () => void,\n) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps\n  renderIsScheduled.current = false\n\n  // If the render was from a store update, clear out that reference and cascade the subscriber update\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null\n    notifyNestedSubs()\n  }\n}\n\n// Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\nfunction subscribeUpdates(\n  shouldHandleStateChanges: boolean,\n  store: Store,\n  subscription: Subscription,\n  childPropsSelector: (state: unknown, props: unknown) => unknown,\n  lastWrapperProps: React.MutableRefObject<unknown>,\n  lastChildProps: React.MutableRefObject<unknown>,\n  renderIsScheduled: React.MutableRefObject<boolean>,\n  isMounted: React.MutableRefObject<boolean>,\n  childPropsFromStoreUpdate: React.MutableRefObject<unknown>,\n  notifyNestedSubs: () => void,\n  // forceComponentUpdateDispatch: React.Dispatch<any>,\n  additionalSubscribeListener: () => void,\n) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return () => {}\n\n  // Capture values for checking if and when this component unmounts\n  let didUnsubscribe = false\n  let lastThrownError: Error | null = null\n\n  // We'll run this callback every time a store subscription update propagates to this component\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return\n    }\n\n    // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n    const latestStoreState = store.getState()\n\n    let newChildProps, error\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(\n        latestStoreState,\n        lastWrapperProps.current,\n      )\n    } catch (e) {\n      error = e\n      lastThrownError = e as Error | null\n    }\n\n    if (!error) {\n      lastThrownError = null\n    }\n\n    // If the child props haven't changed, nothing to do here - cascade the subscription update\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs()\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps\n      childPropsFromStoreUpdate.current = newChildProps\n      renderIsScheduled.current = true\n\n      // TODO This is hacky and not how `uSES` is meant to be used\n      // Trigger the React `useSyncExternalStore` subscriber\n      additionalSubscribeListener()\n    }\n  }\n\n  // Actually subscribe to the nearest connected ancestor (or store)\n  subscription.onStateChange = checkForUpdates\n  subscription.trySubscribe()\n\n  // Pull data from the store after first render in case the store has\n  // changed since we began.\n  checkForUpdates()\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true\n    subscription.tryUnsubscribe()\n    subscription.onStateChange = null\n\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError\n    }\n  }\n\n  return unsubscribeWrapper\n}\n\n// Reducer initial state creation for our update reducer\nconst initStateUpdates = () => EMPTY_ARRAY\n\nexport interface ConnectProps {\n  /** A custom Context instance that the component can use to access the store from an alternate Provider using that same Context instance */\n  context?: ReactReduxContextInstance\n  /** A Redux store instance to be used for subscriptions instead of the store from a Provider */\n  store?: Store\n}\n\ninterface InternalConnectProps extends ConnectProps {\n  reactReduxForwardedRef?: React.ForwardedRef<unknown>\n}\n\nfunction strictEqual(a: unknown, b: unknown) {\n  return a === b\n}\n\n/**\n * Infers the type of props that a connector will inject into a component.\n */\nexport type ConnectedProps<TConnector> =\n  TConnector extends InferableComponentEnhancerWithProps<\n    infer TInjectedProps,\n    any\n  >\n    ? unknown extends TInjectedProps\n      ? TConnector extends InferableComponentEnhancer<infer TInjectedProps>\n        ? TInjectedProps\n        : never\n      : TInjectedProps\n    : never\n\nexport interface ConnectOptions<\n  State = unknown,\n  TStateProps = {},\n  TOwnProps = {},\n  TMergedProps = {},\n> {\n  forwardRef?: boolean\n  context?: typeof ReactReduxContext\n  areStatesEqual?: (\n    nextState: State,\n    prevState: State,\n    nextOwnProps: TOwnProps,\n    prevOwnProps: TOwnProps,\n  ) => boolean\n\n  areOwnPropsEqual?: (\n    nextOwnProps: TOwnProps,\n    prevOwnProps: TOwnProps,\n  ) => boolean\n\n  areStatePropsEqual?: (\n    nextStateProps: TStateProps,\n    prevStateProps: TStateProps,\n  ) => boolean\n  areMergedPropsEqual?: (\n    nextMergedProps: TMergedProps,\n    prevMergedProps: TMergedProps,\n  ) => boolean\n}\n\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps\n * @param mapDispatchToProps\n * @param mergeProps\n * @param options\n */\nexport interface Connect<DefaultState = unknown> {\n  // tslint:disable:no-unnecessary-generics\n  (): InferableComponentEnhancer<DispatchProp>\n\n  /** mapState only */\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n  ): InferableComponentEnhancerWithProps<TStateProps & DispatchProp, TOwnProps>\n\n  /** mapDispatch only (as a function) */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\n\n  /** mapDispatch only (as an object) */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState and mapDispatch (as a function)*/\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & TDispatchProps,\n    TOwnProps\n  >\n\n  /** mapState and mapDispatch (nullish) */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n  ): InferableComponentEnhancerWithProps<TStateProps, TOwnProps>\n\n  /** mapState and mapDispatch (as an object) */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mergeProps only */\n  <no_state = {}, no_dispatch = {}, TOwnProps = {}, TMergedProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: null | undefined,\n    mergeProps: MergeProps<undefined, DispatchProp, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapState and mergeProps */\n  <\n    TStateProps = {},\n    no_dispatch = {},\n    TOwnProps = {},\n    TMergedProps = {},\n    State = DefaultState,\n  >(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n    mergeProps: MergeProps<TStateProps, DispatchProp, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapDispatch (as a object) and mergeProps */\n  <no_state = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: MergeProps<undefined, TDispatchProps, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n\n  /** mapState and options */\n  <TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: null | undefined,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<DispatchProp & TStateProps, TOwnProps>\n\n  /** mapDispatch (as a function) and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<{}, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>\n\n  /** mapDispatch (as an object) and options*/\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}>(\n    mapStateToProps: null | undefined,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<{}, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState,  mapDispatch (as a function), and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsNonObject<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & TDispatchProps,\n    TOwnProps\n  >\n\n  /** mapState,  mapDispatch (as an object), and options */\n  <TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState>(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: null | undefined,\n    options: ConnectOptions<State, TStateProps, TOwnProps>,\n  ): InferableComponentEnhancerWithProps<\n    TStateProps & ResolveThunks<TDispatchProps>,\n    TOwnProps\n  >\n\n  /** mapState, mapDispatch, mergeProps, and options */\n  <\n    TStateProps = {},\n    TDispatchProps = {},\n    TOwnProps = {},\n    TMergedProps = {},\n    State = DefaultState,\n  >(\n    mapStateToProps: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n    mapDispatchToProps: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n    mergeProps: MergeProps<\n      TStateProps,\n      TDispatchProps,\n      TOwnProps,\n      TMergedProps\n    >,\n    options?: ConnectOptions<State, TStateProps, TOwnProps, TMergedProps>,\n  ): InferableComponentEnhancerWithProps<TMergedProps, TOwnProps>\n  // tslint:enable:no-unnecessary-generics\n}\n\nlet hasWarnedAboutDeprecatedPureOption = false\n\n/**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior / props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that's\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user's responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n */\nfunction connect<\n  TStateProps = {},\n  TDispatchProps = {},\n  TOwnProps = {},\n  TMergedProps = {},\n  State = unknown,\n>(\n  mapStateToProps?: MapStateToPropsParam<TStateProps, TOwnProps, State>,\n  mapDispatchToProps?: MapDispatchToPropsParam<TDispatchProps, TOwnProps>,\n  mergeProps?: MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps>,\n  {\n    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure,\n    areStatesEqual = strictEqual,\n    areOwnPropsEqual = shallowEqual,\n    areStatePropsEqual = shallowEqual,\n    areMergedPropsEqual = shallowEqual,\n\n    // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false,\n\n    // the context consumer to use\n    context = ReactReduxContext,\n  }: ConnectOptions<unknown, unknown, unknown, unknown> = {},\n): unknown {\n  if (process.env.NODE_ENV !== 'production') {\n    if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true\n      warning(\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component',\n      )\n    }\n  }\n\n  const Context = context\n\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps)\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps)\n  const initMergeProps = mergePropsFactory(mergeProps)\n\n  const shouldHandleStateChanges = Boolean(mapStateToProps)\n\n  const wrapWithConnect = <TProps,>(\n    WrappedComponent: ComponentType<TProps>,\n  ) => {\n    type WrappedComponentProps = TProps &\n      ConnectPropsMaybeWithoutContext<TProps>\n\n    if (process.env.NODE_ENV !== 'production') {\n      const isValid = /*#__PURE__*/ isValidElementType(WrappedComponent)\n      if (!isValid)\n        throw new Error(\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\n            WrappedComponent,\n          )}`,\n        )\n    }\n\n    const wrappedComponentName =\n      WrappedComponent.displayName || WrappedComponent.name || 'Component'\n\n    const displayName = `Connect(${wrappedComponentName})`\n\n    const selectorFactoryOptions: SelectorFactoryOptions<\n      any,\n      any,\n      any,\n      any,\n      State\n    > = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual,\n    }\n\n    function ConnectFunction<TOwnProps>(\n      props: InternalConnectProps & TOwnProps,\n    ) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] =\n        React.useMemo(() => {\n          // Distinguish between actual \"data\" props that were passed to the wrapper component,\n          // and values needed to control behavior (forwarded refs, alternate context instances).\n          // To maintain the wrapperProps object reference, memoize this destructuring.\n          const { reactReduxForwardedRef, ...wrapperProps } = props\n          return [props.context, reactReduxForwardedRef, wrapperProps]\n        }, [props])\n\n      const ContextToUse: ReactReduxContextInstance = React.useMemo(() => {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        let ResultContext = Context\n        if (propsContext?.Consumer) {\n          if (process.env.NODE_ENV !== 'production') {\n            const isValid = /*#__PURE__*/ isContextConsumer(\n              // @ts-ignore\n              <propsContext.Consumer />,\n            )\n            if (!isValid) {\n              throw new Error(\n                'You must pass a valid React context consumer as `props.context`',\n              )\n            }\n            ResultContext = propsContext\n          }\n        }\n        return ResultContext\n      }, [propsContext, Context])\n\n      // Retrieve the store and ancestor subscription via context, if available\n      const contextValue = React.useContext(ContextToUse)\n\n      // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n      const didStoreComeFromProps =\n        Boolean(props.store) &&\n        Boolean(props.store!.getState) &&\n        Boolean(props.store!.dispatch)\n      const didStoreComeFromContext =\n        Boolean(contextValue) && Boolean(contextValue!.store)\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !didStoreComeFromProps &&\n        !didStoreComeFromContext\n      ) {\n        throw new Error(\n          `Could not find \"store\" in the context of ` +\n            `\"${displayName}\". Either wrap the root component in a <Provider>, ` +\n            `or pass a custom React context provider to <Provider> and the corresponding ` +\n            `React context consumer to ${displayName} in connect options.`,\n        )\n      }\n\n      // Based on the previous check, one of these must be true\n      const store: Store = didStoreComeFromProps\n        ? props.store!\n        : contextValue!.store\n\n      const getServerState = didStoreComeFromContext\n        ? contextValue!.getServerState\n        : store.getState\n\n      const childPropsSelector = React.useMemo(() => {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return defaultSelectorFactory(store.dispatch, selectorFactoryOptions)\n      }, [store])\n\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\n\n        // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n        const subscription = createSubscription(\n          store,\n          didStoreComeFromProps ? undefined : contextValue!.subscription,\n        )\n\n        // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n        const notifyNestedSubs =\n          subscription.notifyNestedSubs.bind(subscription)\n\n        return [subscription, notifyNestedSubs]\n      }, [store, didStoreComeFromProps, contextValue])\n\n      // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue!\n        }\n\n        // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n        return {\n          ...contextValue,\n          subscription,\n        } as ReactReduxContextValue\n      }, [didStoreComeFromProps, contextValue, subscription])\n\n      // Set up refs to coordinate values between the subscription effect and the render logic\n      const lastChildProps = React.useRef<unknown>(undefined)\n      const lastWrapperProps = React.useRef(wrapperProps)\n      const childPropsFromStoreUpdate = React.useRef<unknown>(undefined)\n      const renderIsScheduled = React.useRef(false)\n      const isMounted = React.useRef(false)\n\n      // TODO: Change this to `React.useRef<Error>(undefined)` after upgrading to React 19.\n      /**\n       * @todo Change this to `React.useRef<Error>(undefined)` after upgrading to React 19.\n       */\n      const latestSubscriptionCallbackError = React.useRef<Error | undefined>(\n        undefined,\n      )\n\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true\n        return () => {\n          isMounted.current = false\n        }\n      }, [])\n\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          // Tricky logic here:\n          // - This render may have been triggered by a Redux store update that produced new child props\n          // - However, we may have gotten new wrapper props after that\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n          if (\n            childPropsFromStoreUpdate.current &&\n            wrapperProps === lastWrapperProps.current\n          ) {\n            return childPropsFromStoreUpdate.current\n          }\n\n          // TODO We're reading the store directly in render() here. Bad idea?\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n          // to determine what the child props should be.\n          return childPropsSelector(store.getState(), wrapperProps)\n        }\n        return selector\n      }, [store, wrapperProps])\n\n      // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = (reactListener: () => void) => {\n          if (!subscription) {\n            return () => {}\n          }\n\n          return subscribeUpdates(\n            shouldHandleStateChanges,\n            store,\n            subscription,\n            // @ts-ignore\n            childPropsSelector,\n            lastWrapperProps,\n            lastChildProps,\n            renderIsScheduled,\n            isMounted,\n            childPropsFromStoreUpdate,\n            notifyNestedSubs,\n            reactListener,\n          )\n        }\n\n        return subscribe\n      }, [subscription])\n\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        wrapperProps,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs,\n      ])\n\n      let actualChildProps: Record<string, unknown>\n\n      try {\n        actualChildProps = React.useSyncExternalStore(\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n          subscribeForReact,\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n          actualChildPropsSelector,\n          getServerState\n            ? () => childPropsSelector(getServerState(), wrapperProps)\n            : actualChildPropsSelector,\n        )\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          // eslint-disable-next-line no-extra-semi\n          ;(err as Error).message +=\n            `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`\n        }\n\n        throw err\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = undefined\n        childPropsFromStoreUpdate.current = undefined\n        lastChildProps.current = actualChildProps\n      })\n\n      // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (\n          // @ts-ignore\n          <WrappedComponent\n            {...actualChildProps}\n            ref={reactReduxForwardedRef}\n          />\n        )\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps])\n\n      // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return (\n            <ContextToUse.Provider value={overriddenContextValue}>\n              {renderedWrappedComponent}\n            </ContextToUse.Provider>\n          )\n        }\n\n        return renderedWrappedComponent\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\n\n      return renderedChild\n    }\n\n    const _Connect = React.memo(ConnectFunction)\n\n    type ConnectedWrapperComponent = typeof _Connect & {\n      WrappedComponent: typeof WrappedComponent\n    }\n\n    // Add a hacky cast to get the right output type\n    const Connect = _Connect as unknown as ConnectedComponent<\n      typeof WrappedComponent,\n      WrappedComponentProps\n    >\n    Connect.WrappedComponent = WrappedComponent\n    Connect.displayName = ConnectFunction.displayName = displayName\n\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(\n        function forwardConnectRef(props, ref) {\n          // @ts-ignore\n          return <Connect {...props} reactReduxForwardedRef={ref} />\n        },\n      )\n\n      const forwarded = _forwarded as ConnectedWrapperComponent\n      forwarded.displayName = displayName\n      forwarded.WrappedComponent = WrappedComponent\n      return /*#__PURE__*/ hoistStatics(forwarded, WrappedComponent)\n    }\n\n    return /*#__PURE__*/ hoistStatics(Connect, WrappedComponent)\n  }\n\n  return wrapWithConnect\n}\n\nexport default connect as Connect\n","import type { Context, ReactNode } from 'react'\nimport { React } from '../utils/react'\nimport type { Action, Store, UnknownAction } from 'redux'\nimport type { DevModeCheckFrequency } from '../hooks/useSelector'\nimport { createSubscription } from '../utils/Subscription'\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect'\nimport type { ReactReduxContextValue } from './Context'\nimport { ReactReduxContext } from './Context'\n\nexport interface ProviderProps<\n  A extends Action<string> = UnknownAction,\n  S = unknown,\n> {\n  /**\n   * The single Redux store in your application.\n   */\n  store: Store<S, A>\n\n  /**\n   * An optional server state snapshot. Will be used during initial hydration render if available, to ensure that the UI output is consistent with the HTML generated on the server.\n   */\n  serverState?: S\n\n  /**\n   * Optional context to be used internally in react-redux. Use React.createContext() to create a context to be used.\n   * If this is used, you'll need to customize `connect` by supplying the same context provided to the Provider.\n   * Set the initial value to null, and the hooks will error\n   * if this is not overwritten by Provider.\n   */\n  context?: Context<ReactReduxContextValue<S, A> | null>\n\n  /**\n   * Determines the frequency of stability checks for all selectors.\n   * This setting overrides the global configuration for\n   * the `useSelector` stability check, allowing you to specify how often\n   * these checks should occur in development mode.\n   *\n   * @since 8.1.0\n   */\n  stabilityCheck?: DevModeCheckFrequency\n\n  /**\n   * Determines the frequency of identity function checks for all selectors.\n   * This setting overrides the global configuration for\n   * the `useSelector` identity function check, allowing you to specify how often\n   * these checks should occur in development mode.\n   *\n   * **Note**: Previously referred to as `noopCheck`.\n   *\n   * @since 9.0.0\n   */\n  identityFunctionCheck?: DevModeCheckFrequency\n\n  children: ReactNode\n}\n\nfunction Provider<A extends Action<string> = UnknownAction, S = unknown>(\n  providerProps: ProviderProps<A, S>,\n) {\n  const { children, context, serverState, store } = providerProps\n\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store)\n\n    const baseContextValue = {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : undefined,\n    }\n\n    if (process.env.NODE_ENV === 'production') {\n      return baseContextValue\n    } else {\n      const { identityFunctionCheck = 'once', stabilityCheck = 'once' } =\n        providerProps\n\n      return /* @__PURE__ */ Object.assign(baseContextValue, {\n        stabilityCheck,\n        identityFunctionCheck,\n      })\n    }\n  }, [store, serverState])\n\n  const previousState = React.useMemo(() => store.getState(), [store])\n\n  useIsomorphicLayoutEffect(() => {\n    const { subscription } = contextValue\n    subscription.onStateChange = subscription.notifyNestedSubs\n    subscription.trySubscribe()\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs()\n    }\n    return () => {\n      subscription.tryUnsubscribe()\n      subscription.onStateChange = undefined\n    }\n  }, [contextValue, previousState])\n\n  const Context = context || ReactReduxContext\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>\n}\n\nexport default Provider\n","import { React } from '../utils/react'\nimport { ReactReduxContext } from '../components/Context'\nimport type { ReactReduxContextValue } from '../components/Context'\n\n/**\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\n */\nexport function createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext(): ReactReduxContextValue {\n    const contextValue = React.useContext(context)\n\n    if (process.env.NODE_ENV !== 'production' && !contextValue) {\n      throw new Error(\n        'could not find react-redux context value; please ensure the component is wrapped in a <Provider>',\n      )\n    }\n\n    return contextValue!\n  }\n}\n\n/**\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @returns {any} the value of the `ReactReduxContext`\n *\n * @example\n *\n * import React from 'react'\n * import { useReduxContext } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const { store } = useReduxContext()\n *   return <div>{store.getState()}</div>\n * }\n */\nexport const useReduxContext = /*#__PURE__*/ createReduxContextHook()\n","import type { Context } from 'react'\nimport type { Action, Store } from 'redux'\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport {\n  createReduxContextHook,\n  useReduxContext as useDefaultReduxContext,\n} from './useReduxContext'\n\n/**\n * Represents a type that extracts the action type from a given Redux store.\n *\n * @template StoreType - The specific type of the Redux store.\n *\n * @since 9.1.0\n * @internal\n */\nexport type ExtractStoreActionType<StoreType extends Store> =\n  StoreType extends Store<any, infer ActionType> ? ActionType : never\n\n/**\n * Represents a custom hook that provides access to the Redux store.\n *\n * @template StoreType - The specific type of the Redux store that gets returned.\n *\n * @since 9.1.0\n * @public\n */\nexport interface UseStore<StoreType extends Store> {\n  /**\n   * Returns the Redux store instance.\n   *\n   * @returns The Redux store instance.\n   */\n  (): StoreType\n\n  /**\n   * Returns the Redux store instance with specific state and action types.\n   *\n   * @returns The Redux store with the specified state and action types.\n   *\n   * @template StateType - The specific type of the state used in the store.\n   * @template ActionType - The specific type of the actions used in the store.\n   */\n  <\n    StateType extends ReturnType<StoreType['getState']> = ReturnType<\n      StoreType['getState']\n    >,\n    ActionType extends Action = ExtractStoreActionType<Store>,\n  >(): Store<StateType, ActionType>\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useStore useStore}\n   * where the type of the Redux `store` is predefined.\n   *\n   * This allows you to set the `store` type once, eliminating the need to\n   * specify it with every {@linkcode useStore useStore} call.\n   *\n   * @returns A pre-typed `useStore` with the store type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppStore = useStore.withTypes<AppStore>()\n   * ```\n   *\n   * @template OverrideStoreType - The specific type of the Redux store that gets returned.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideStoreType extends StoreType,\n  >() => UseStore<OverrideStoreType>\n}\n\n/**\n * Hook factory, which creates a `useStore` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useStore` hook bound to the specified context.\n */\nexport function createStoreHook<\n  StateType = unknown,\n  ActionType extends Action = Action,\n>(\n  // @ts-ignore\n  context?: Context<ReactReduxContextValue<\n    StateType,\n    ActionType\n  > | null> = ReactReduxContext,\n) {\n  const useReduxContext =\n    context === ReactReduxContext\n      ? useDefaultReduxContext\n      : // @ts-ignore\n        createReduxContextHook(context)\n  const useStore = () => {\n    const { store } = useReduxContext()\n    return store\n  }\n\n  Object.assign(useStore, {\n    withTypes: () => useStore,\n  })\n\n  return useStore as UseStore<Store<StateType, ActionType>>\n}\n\n/**\n * A hook to access the redux store.\n *\n * @returns {any} the redux store\n *\n * @example\n *\n * import React from 'react'\n * import { useStore } from 'react-redux'\n *\n * export const ExampleComponent = () => {\n *   const store = useStore()\n *   return <div>{store.getState()}</div>\n * }\n */\nexport const useStore = /*#__PURE__*/ createStoreHook()\n","import type { Context } from 'react'\nimport type { Action, Dispatch, UnknownAction } from 'redux'\n\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport { createStoreHook, useStore as useDefaultStore } from './useStore'\n\n/**\n * Represents a custom hook that provides a dispatch function\n * from the Redux store.\n *\n * @template DispatchType - The specific type of the dispatch function.\n *\n * @since 9.1.0\n * @public\n */\nexport interface UseDispatch<\n  DispatchType extends Dispatch<UnknownAction> = Dispatch<UnknownAction>,\n> {\n  /**\n   * Returns the dispatch function from the Redux store.\n   *\n   * @returns The dispatch function from the Redux store.\n   *\n   * @template AppDispatch - The specific type of the dispatch function.\n   */\n  <AppDispatch extends DispatchType = DispatchType>(): AppDispatch\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useDispatch useDispatch}\n   * where the type of the `dispatch` function is predefined.\n   *\n   * This allows you to set the `dispatch` type once, eliminating the need to\n   * specify it with every {@linkcode useDispatch useDispatch} call.\n   *\n   * @returns A pre-typed `useDispatch` with the dispatch type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppDispatch = useDispatch.withTypes<AppDispatch>()\n   * ```\n   *\n   * @template OverrideDispatchType - The specific type of the dispatch function.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideDispatchType extends DispatchType,\n  >() => UseDispatch<OverrideDispatchType>\n}\n\n/**\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useDispatch` hook bound to the specified context.\n */\nexport function createDispatchHook<\n  StateType = unknown,\n  ActionType extends Action = UnknownAction,\n>(\n  // @ts-ignore\n  context?: Context<ReactReduxContextValue<\n    StateType,\n    ActionType\n  > | null> = ReactReduxContext,\n) {\n  const useStore =\n    context === ReactReduxContext ? useDefaultStore : createStoreHook(context)\n\n  const useDispatch = () => {\n    const store = useStore()\n    return store.dispatch\n  }\n\n  Object.assign(useDispatch, {\n    withTypes: () => useDispatch,\n  })\n\n  return useDispatch as UseDispatch<Dispatch<ActionType>>\n}\n\n/**\n * A hook to access the redux `dispatch` function.\n *\n * @returns {any|function} redux store's `dispatch` function\n *\n * @example\n *\n * import React, { useCallback } from 'react'\n * import { useDispatch } from 'react-redux'\n *\n * export const CounterComponent = ({ value }) => {\n *   const dispatch = useDispatch()\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\n *   return (\n *     <div>\n *       <span>{value}</span>\n *       <button onClick={increaseCounter}>Increase counter</button>\n *     </div>\n *   )\n * }\n */\nexport const useDispatch = /*#__PURE__*/ createDispatchHook()\n","//import * as React from 'react'\nimport { React } from '../utils/react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector.js'\nimport type { ReactReduxContextValue } from '../components/Context'\nimport { ReactReduxContext } from '../components/Context'\nimport type { EqualityFn, NoInfer } from '../types'\nimport {\n  createReduxContextHook,\n  useReduxContext as useDefaultReduxContext,\n} from './useReduxContext'\n\n/**\n * The frequency of development mode checks.\n *\n * @since 8.1.0\n * @internal\n */\nexport type DevModeCheckFrequency = 'never' | 'once' | 'always'\n\n/**\n * Represents the configuration for development mode checks.\n *\n * @since 9.0.0\n * @internal\n */\nexport interface DevModeChecks {\n  /**\n   * Overrides the global stability check for the selector.\n   * - `once` - Run only the first time the selector is called.\n   * - `always` - Run every time the selector is called.\n   * - `never` - Never run the stability check.\n   *\n   * @default 'once'\n   *\n   * @since 8.1.0\n   */\n  stabilityCheck: DevModeCheckFrequency\n\n  /**\n   * Overrides the global identity function check for the selector.\n   * - `once` - Run only the first time the selector is called.\n   * - `always` - Run every time the selector is called.\n   * - `never` - Never run the identity function check.\n   *\n   * **Note**: Previously referred to as `noopCheck`.\n   *\n   * @default 'once'\n   *\n   * @since 9.0.0\n   */\n  identityFunctionCheck: DevModeCheckFrequency\n}\n\nexport interface UseSelectorOptions<Selected = unknown> {\n  equalityFn?: EqualityFn<Selected>\n\n  /**\n   * `useSelector` performs additional checks in development mode to help\n   * identify and warn about potential issues in selector behavior. This\n   * option allows you to customize the behavior of these checks per selector.\n   *\n   * @since 9.0.0\n   */\n  devModeChecks?: Partial<DevModeChecks>\n}\n\n/**\n * Represents a custom hook that allows you to extract data from the\n * Redux store state, using a selector function. The selector function\n * takes the current state as an argument and returns a part of the state\n * or some derived data. The hook also supports an optional equality\n * function or options object to customize its behavior.\n *\n * @template StateType - The specific type of state this hook operates on.\n *\n * @public\n */\nexport interface UseSelector<StateType = unknown> {\n  /**\n   * A function that takes a selector function as its first argument.\n   * The selector function is responsible for selecting a part of\n   * the Redux store's state or computing derived data.\n   *\n   * @param selector - A function that receives the current state and returns a part of the state or some derived data.\n   * @param equalityFnOrOptions - An optional equality function or options object for customizing the behavior of the selector.\n   * @returns The selected part of the state or derived data.\n   *\n   * @template TState - The specific type of state this hook operates on.\n   * @template Selected - The type of the value that the selector function will return.\n   */\n  <TState extends StateType = StateType, Selected = unknown>(\n    selector: (state: TState) => Selected,\n    equalityFnOrOptions?: EqualityFn<Selected> | UseSelectorOptions<Selected>,\n  ): Selected\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode useSelector useSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every {@linkcode useSelector useSelector} call.\n   *\n   * @returns A pre-typed `useSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * export const useAppSelector = useSelector.withTypes<RootState>()\n   * ```\n   *\n   * @template OverrideStateType - The specific type of state this hook operates on.\n   *\n   * @since 9.1.0\n   */\n  withTypes: <\n    OverrideStateType extends StateType,\n  >() => UseSelector<OverrideStateType>\n}\n\nconst refEquality: EqualityFn<any> = (a, b) => a === b\n\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\nexport function createSelectorHook(\n  context: React.Context<ReactReduxContextValue<\n    any,\n    any\n  > | null> = ReactReduxContext,\n): UseSelector {\n  const useReduxContext =\n    context === ReactReduxContext\n      ? useDefaultReduxContext\n      : createReduxContextHook(context)\n\n  const useSelector = <TState, Selected>(\n    selector: (state: TState) => Selected,\n    equalityFnOrOptions:\n      | EqualityFn<NoInfer<Selected>>\n      | UseSelectorOptions<NoInfer<Selected>> = {},\n  ): Selected => {\n    const { equalityFn = refEquality } =\n      typeof equalityFnOrOptions === 'function'\n        ? { equalityFn: equalityFnOrOptions }\n        : equalityFnOrOptions\n    if (process.env.NODE_ENV !== 'production') {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`)\n      }\n      if (typeof selector !== 'function') {\n        throw new Error(`You must pass a function as a selector to useSelector`)\n      }\n      if (typeof equalityFn !== 'function') {\n        throw new Error(\n          `You must pass a function as an equality function to useSelector`,\n        )\n      }\n    }\n\n    const reduxContext = useReduxContext()\n\n    const { store, subscription, getServerState } = reduxContext\n\n    const firstRun = React.useRef(true)\n\n    const wrappedSelector = React.useCallback<typeof selector>(\n      {\n        [selector.name](state: TState) {\n          const selected = selector(state)\n          if (process.env.NODE_ENV !== 'production') {\n            const { devModeChecks = {} } =\n              typeof equalityFnOrOptions === 'function'\n                ? {}\n                : equalityFnOrOptions\n            const { identityFunctionCheck, stabilityCheck } = reduxContext\n            const {\n              identityFunctionCheck: finalIdentityFunctionCheck,\n              stabilityCheck: finalStabilityCheck,\n            } = {\n              stabilityCheck,\n              identityFunctionCheck,\n              ...devModeChecks,\n            }\n            if (\n              finalStabilityCheck === 'always' ||\n              (finalStabilityCheck === 'once' && firstRun.current)\n            ) {\n              const toCompare = selector(state)\n              if (!equalityFn(selected, toCompare)) {\n                let stack: string | undefined = undefined\n                try {\n                  throw new Error()\n                } catch (e) {\n                  // eslint-disable-next-line no-extra-semi\n                  ;({ stack } = e as Error)\n                }\n                console.warn(\n                  'Selector ' +\n                    (selector.name || 'unknown') +\n                    ' returned a different result when called with the same parameters. This can lead to unnecessary rerenders.' +\n                    '\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization',\n                  {\n                    state,\n                    selected,\n                    selected2: toCompare,\n                    stack,\n                  },\n                )\n              }\n            }\n            if (\n              finalIdentityFunctionCheck === 'always' ||\n              (finalIdentityFunctionCheck === 'once' && firstRun.current)\n            ) {\n              // @ts-ignore\n              if (selected === state) {\n                let stack: string | undefined = undefined\n                try {\n                  throw new Error()\n                } catch (e) {\n                  // eslint-disable-next-line no-extra-semi\n                  ;({ stack } = e as Error)\n                }\n                console.warn(\n                  'Selector ' +\n                    (selector.name || 'unknown') +\n                    ' returned the root state when called. This can lead to unnecessary rerenders.' +\n                    '\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.',\n                  { stack },\n                )\n              }\n            }\n            if (firstRun.current) firstRun.current = false\n          }\n          return selected\n        },\n      }[selector.name],\n      [selector],\n    )\n\n    const selectedState = useSyncExternalStoreWithSelector(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      wrappedSelector,\n      equalityFn,\n    )\n\n    React.useDebugValue(selectedState)\n\n    return selectedState\n  }\n\n  Object.assign(useSelector, {\n    withTypes: () => useSelector,\n  })\n\n  return useSelector as UseSelector\n}\n\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\nexport const useSelector = /*#__PURE__*/ createSelectorHook()\n","import connect from './components/connect'\nexport type {\n  Connect,\n  ConnectProps,\n  ConnectedProps,\n} from './components/connect'\n\nimport shallowEqual from './utils/shallowEqual'\n\nimport Provider from './components/Provider'\nimport { defaultNoopBatch } from './utils/batch'\n\nexport { ReactReduxContext } from './components/Context'\nexport type { ReactReduxContextValue } from './components/Context'\n\nexport type { ProviderProps } from './components/Provider'\n\nexport type {\n  MapDispatchToProps,\n  MapDispatchToPropsFactory,\n  MapDispatchToPropsFunction,\n  MapDispatchToPropsNonObject,\n  MapDispatchToPropsParam,\n  MapStateToProps,\n  MapStateToPropsFactory,\n  MapStateToPropsParam,\n  MergeProps,\n  Selector,\n  SelectorFactory,\n} from './connect/selectorFactory'\n\nexport { createDispatchHook, useDispatch } from './hooks/useDispatch'\nexport type { UseDispatch } from './hooks/useDispatch'\n\nexport { createSelectorHook, useSelector } from './hooks/useSelector'\nexport type { UseSelector } from './hooks/useSelector'\n\nexport { createStoreHook, useStore } from './hooks/useStore'\nexport type { UseStore } from './hooks/useStore'\n\nexport type { Subscription } from './utils/Subscription'\n\nexport * from './types'\n\n/**\n * @deprecated As of React 18, batching is enabled by default for ReactDOM and React Native.\n * This is now a no-op that immediately runs the callback.\n */\nconst batch = defaultNoopBatch\n\nexport { Provider, batch, connect, shallowEqual }\n"]},"metadata":{},"sourceType":"module"}